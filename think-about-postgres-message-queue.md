## 关于PostgreSQL消息队列的思考
### 背景
需要调研PostgreSQL实现消息队列以替换RabbitMQ的方案。

给出各扩展和RabbitMQ的功能、性能对比，如果pgmq、pgq都无法满足，需要再分析一下PostgreSQL是否有其他功能可以替换RabbitMQ。


### PostgreSQL实现消息队列

#### 实现方案
PostgreSQL目前的实现消息队列方案有：
- pgmq
- pgq

#### 基本原理
数据库实现消息队列，并不是像RabbitMQ一样，实现了AMQP协议，而是通过数据库机制来实现类似消息队列的功能。对外提供的接口是SQL接口。 数据库实现消息队列，通常都是通过表来实现队列，PGQ也是基于表来实现消息队列。一个队列就是一张表，客户端发送消息到队列，实际上就是向表中插入了一条数据。消费者读消息，就是读这张抽象为队列的表，消费消息实际上就是从被抽象为队列的表中删除消息。为了方便用户使用，封装了一些API来操作队列，与RabbitMQ不同的是，这里提供的是纯SQL接口，用户可以直接使用SQL来操作队列，比如发送消息、消费消息等。

#### 对替换RabbitMQ的思考
如果想要完整的替换RabbitMQ，如果用到了RabbitMQ中的复杂功能，则PostgreSQL中的替换方案基本不可行。无论是pgmq还是pgq，只支持基本的消息队列功能，没有提供丰富的路由等功能。想要对业务无感替换，是做不到的，提供的API为SQL接口。RabbitMQ为独立的专业消息中间件，而PostgreSQL是一个数据库，完全替换基本上不可行，但是，某些场景下，可以用PostgreSQL的消息队列来满足业务需求。重点应该是找到PostgreSQL消息队列适合的场景，而不是完全替换RabbitMQ。


### 哪些场景建议使用PostgreSQL消息队列
本身技术栈已经是PostgreSQL，并且对消息队列功能要求不高，比如不需要消息持久化，不需要消息确认，不需要消息重试，不需要消息路由，不需要消息优先级，不需要消息过期等。因为RabbitMQ等独立消息中间件会增加运维成本。


如果本身的技术栈没有PostgreSQL，不推荐引入PostgreSQL消息队列，因为PostgreSQL的消息队列功能比较简单，如果要实现复杂的消息队列功能，则需要引入RabbitMQ等独立消息中间件。

其最佳的适用场景：
- 数据库事务内异步操作：需要与数据库事务强集成的异步任务处理场景（如订单创建后发送短信，订单支付成功后发送邮件）
- 轻量级消息队列：场景简单，不需要复杂路由、优先级、过期等高级功能的消息队列场景，只需简单消息队列功能即可满足需求，且消息量适中，不需要高并发、高吞吐量的消息队列场景。


### RabbitMQ与PGMQ的对比

#### 功能对比

|功能对比|RabbitMQ|PGMQ|PGQ|
|--|--|--|--|
|消息持久化|支持|支持|支持|
|消息确认机制|支持ACK/NACK机制|数据库事务保证，无需消息确认机制|数据库事务保证，无需消息确认机制|
|消息重试|支持|不支持（如果事务失败，业务层去处理重试的问题） |不支持（如果事务失败，业务层去处理重试的问题）|
|消息路由|支持多种路由规则，如fanout、direct、topic等|不支持|不支持|
|消息优先级|支持|不支持|不支持|
|消息过期|支持|不支持|不支持|
|事务| 支持AMQP协议事务机制、生产者确认机制| 支持数据库事务| 支持数据库事务|

因PGQ与PGMQ实现原理基本一致，故只对比PGMQ与RabbitMQ。

|特性 |PGMQ|RabbitMQ|
|--|--|--|
|架构与实现|PGMQ是构建在PostgreSQL数据库之上的消息队列系统，无需额外部署独立的消息队列服务|Erlang实现，独立的消息队列中间件，采用AMQP协议，单独部署和管理，可集群化以实现高可用和扩展性|
|性能| 性能受限于数据库性能，适合小规模的消息处理场景、高并发、大规模消息处理的场景下受限于PostgreSQL的写入性能 | 高并发、大规模消息处理的场景下，性能表现良好，延迟较低|
|可靠性| 继承PostgreSQL的可靠性，支持事务处理，可以保证消息的原子性和一致性。依赖数据库备份和恢复机制| 提供多种可靠性机制，如消息确认、持久化存储、支持集群镜像队列等，支持集群自动故障转移|
|协议支持|仅支持SQL接口| 支持多种消息协议，如AMQP、MQTT、STOMP等|
|消息持久化| 依赖PostgreSQL的持久化机制（消息实际上是存储在表中）| 支持磁盘持久化|
|消息路由| 简单队列模型、无复杂路由规则| 支持灵活的路由规则，如fanout、direct、topic等|
|消息确认机制| 支持visibility timeout、显式删除| 支持ACK/NACK机制|

#### 性能对比：

8核8G

##### RabbitMQ 测试结果：

基础场景：单生产者单消费者
```bash
# 消息大小 1KB，队列名为 "test_queue"
java -jar perf-test-2.23.0.jar -x 1 -y 1 -s 1024 -u "test_queue"
id: test-144514-761, sending rate avg: 26583 msg/s
id: test-144514-761, receiving rate avg: 26580 msg/s
id: test-144514-761, consumer latency min/median/75th/95th/99th 8766/23473/26926/37135/63106 µs
```
发送/接收吞吐量：26580 msg/s， 时延：37135 µs

高并发场景：10 生产者 + 10 消费者
```bash
# 持续 60 秒，消息大小 512B，预取值 500
java -jar perf-test-2.23.0.jar -x 10 -y 10 -s 512 --time 60 -q 500
id: test-145333-156, sending rate avg: 6400 msg/s
id: test-145333-156, receiving rate avg: 49924 msg/s
id: test-145333-156, consumer latency min/median/75th/95th/99th 66898/22712797/25327685/28434121/29969780 µs
```
发送吞吐量：6400 msg/s， 接收吞吐量：49924 msg/s， 时延：28434121 µs

##### PGMQ 测试结果：
